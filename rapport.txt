ğŸ“„ RAPPORT DE PROJET - SystÃ¨me de Recommandation Musicale

ğŸ¯ 1. INTRODUCTION
1.1 Contexte
Les systÃ¨mes de recommandation sont devenus essentiels dans l'industrie musicale moderne. Des plateformes comme Spotify, Apple Music et Deezer utilisent ces technologies pour personnaliser l'expÃ©rience utilisateur et favoriser la dÃ©couverte de nouveaux contenus.
1.2 ProblÃ©matique
Comment dÃ©velopper un systÃ¨me de recommandation musicale capable de :

Recommander des chansons pertinentes basÃ©es sur les prÃ©fÃ©rences utilisateurs
Favoriser la dÃ©couverte de nouvelles chansons
GÃ©rer les utilisateurs avec peu d'historique (cold start)
Ã‰quilibrer pertinence et diversitÃ©

1.3 Objectifs du Projet
Objectif principal : DÃ©velopper et comparer trois approches de recommandation musicale.
Objectifs spÃ©cifiques :

Analyser et prÃ©parer le dataset MCRec-30M
ImplÃ©menter un modÃ¨le Content-Based (similaritÃ© de contenu)
ImplÃ©menter un modÃ¨le Collaborative Filtering (filtrage collaboratif)
DÃ©velopper un modÃ¨le Hybrid combinant les deux approches
Ã‰valuer et comparer les performances
DÃ©ployer le meilleur modÃ¨le dans une application web


ğŸ“Š 2. DATASET2.1 Source
Fichier unique : personalized_music_recommendation_dataset.csvDataset complet contenant toutes les informations nÃ©cessaires : utilisateurs, chansons, interactions et contexte d'Ã©coute.2.2 Structure du DatasetLe dataset contient trois types d'informations intÃ©grÃ©es dans un seul fichier :A. Informations Utilisateurs (9 colonnes)

DÃ©mographie : age, gender, location
Comportement : listening_time_mins, sessions_per_day, recent_skip_rate
PrÃ©fÃ©rences : preferred_genre, preferred_artist
Abonnement : subscription_type (Free/Premium)
B. MÃ©tadonnÃ©es Musicales (18 colonnes)

Identification : song_id, title, artist, album
CaractÃ©ristiques : genre, release_year, language, duration_sec
Features audio : tempo, energy, danceability, acousticness, valence, loudness
PopularitÃ© : popularity, explicit
Analyse : lyrics_sentiment, emotion_tag
C. Interactions et Contexte (13 colonnes)

Temporel : timestamp, time_of_day, day_of_week
Comportement d'Ã©coute : play_count, skip_count, finished_song, repeat_count
Session : context_type, song_position_in_session, session_duration_mins
Appareil : device_type (Mobile, Smart Speaker, Desktop)
Variable cible : liked (0 ou 1)
2.3 CaractÃ©ristiques ClÃ©s
70,129 interactions (lignes) reprÃ©sentant des Ã©coutes individuelles
50 utilisateurs uniques avec historiques d'Ã©coute variÃ©s
200 chansons uniques rÃ©parties sur 5 genres (Pop, Rock, Jazz, EDM, Autres)
DensitÃ© de la matrice : 7% (matrice trÃ¨s sparse)
PÃ©riode temporelle : 4 ans de donnÃ©es (2021-2025)
Distribution des genres : Pop (40%), Rock (30%), Jazz (15%), EDM (10%), Autres (5%)
Features audio enrichies : 14 caractÃ©ristiques numÃ©riques par chanson
2.4 Richesse du DatasetAvantages par rapport aux datasets classiques :

âœ… Dataset unifiÃ© : Toutes les informations dans un seul fichier
âœ… Contexte d'Ã©coute : Heure, jour, type d'activitÃ© (Workout, Relax)
âœ… Comportement dÃ©taillÃ© : Skips, rÃ©pÃ©titions, ajouts aux playlists
âœ… Features audio avancÃ©es : Tempo, Ã©nergie, valence, acousticness
âœ… Sentiment et Ã©motions : Lyrics sentiment, emotion tags


ğŸ”§ 3. MÃ‰THODOLOGIE
3.1 Architecture du Projet

music-recommendation-system/
â”‚
â”œâ”€â”€ config.yaml                          # âœ… Configuration
â”‚
â”œâ”€â”€ data/
â”‚   â”œâ”€â”€ raw/                             # âœ… DonnÃ©es brutes
â”‚   â”‚   â””â”€â”€ personalized_music_recommendation_dataset.csv
â”‚   â”œâ”€â”€ processed/                       # âœ… DonnÃ©es prÃ©traitÃ©es
â”‚   â”‚   â”œâ”€â”€ train_data.csv
â”‚   â”‚   â”œâ”€â”€ test_data.csv
â”‚   â”‚   â”œâ”€â”€ songs_metadata.csv
â”‚   â”‚   â””â”€â”€ songs_content_features.csv
â”‚   â””â”€â”€ models/                          # âœ… ModÃ¨les entraÃ®nÃ©s
â”‚       â”œâ”€â”€ content_based_model.pkl
â”‚       â”œâ”€â”€ collaborative_model.pkl
â”‚       â”œâ”€â”€ hybrid_config.json
â”‚       â”œâ”€â”€ evaluation_report.json
â”‚       â””â”€â”€ modeling_summary.json
â”‚
â”œâ”€â”€ notebooks/                           # âœ… Vos 3 notebooks
â”‚   â”œâ”€â”€ 01_exploration.ipynb
â”‚   â”œâ”€â”€ 02_preprocessing.ipynb
â”‚   â””â”€â”€ 03_modeling.ipynb
â”‚
â””â”€â”€ app/                                 # âœ… Application Streamlit
    â”œâ”€â”€ config.py
    â”œâ”€â”€ models.py
    â”œâ”€â”€ utils.py
    â””â”€â”€ streamlit_app.py



ğŸ““ 4. NOTEBOOKS ET Ã‰TAPES DE DÃ‰VELOPPEMENT
ğŸ“‹ config.yaml
RÃ´le : Fichier de configuration centralisÃ© pour tous les paramÃ¨tres du projet.
Contenu :

ParamÃ¨tres de split train/test (80/20, stratifiÃ©)
HyperparamÃ¨tres des modÃ¨les (n_factors=50, learning_rate=0.005)
MÃ©triques d'Ã©valuation (Precision@K avec K=[5,10,20])
Poids du modÃ¨le hybride (Î±=0.5, Î²=0.5)

UtilitÃ© : Assure la reproductibilitÃ© et facilite le tuning des hyperparamÃ¨tres.

ğŸ““ Notebook 1 : 01_exploration.ipynb
Objectif : Comprendre la structure et les caractÃ©ristiques du dataset avant tout traitement.
Analyses rÃ©alisÃ©es :

Statistiques descriptives

Nombre d'utilisateurs, chansons, interactions
Distribution des interactions par utilisateur
DensitÃ© de la matrice (7%)


Analyse de la popularitÃ©

Top 10 chansons reprÃ©sentent 40% des Ã©coutes
Distribution des genres (Pop 40%, Rock 30%, Jazz 15%, EDM 10%, Autres 5%)


Analyse temporelle

Ã‰volution des Ã©coutes sur 4 ans
Identification de tendances saisonniÃ¨res


Identification des challenges

Matrice trÃ¨s sparse â†’ DifficultÃ© pour collaborative filtering
Cold start prÃ©vu pour 40% des utilisateurs
Biais de popularitÃ© Ã  gÃ©rer



Sorties : Visualisations, statistiques, insights pour le prÃ©traitement.

ğŸ““ Notebook 2 : 02_preprocessing.ipynb
Objectif : Transformer les donnÃ©es brutes en formats exploitables par les algorithmes.
Ã‰tapes principales :

Nettoyage

Suppression des doublons (68 lignes)
Conversion des timestamps
Filtrage des utilisateurs/chansons avec <5 interactions


Feature Engineering

CrÃ©ation de la variable binaire liked (seuil = mÃ©diane)
Normalisation des features audio (tempo, energy, danceability)
One-hot encoding des variables catÃ©gorielles (genre, artiste, langue)
RÃ©sultat : 58 features par chanson (4 audio + 54 catÃ©gorielles)


Matrice de SimilaritÃ© (Content-Based)

Calcul de la similaritÃ© cosinus entre chansons
Matrice 200Ã—200 normalisÃ©e L2
Sauvegarde en format sparse (Ã©conomie mÃ©moire)


Split Train/Test StratifiÃ©

Innovation clÃ© : Split par utilisateur pour garantir chaque utilisateur dans train ET test
Train : 56,103 interactions (80%)
Test : 14,026 interactions (20%)
RÃ©sultat : 100% des utilisateurs prÃ©sents dans les deux ensembles



Sorties :

train_data.csv, test_data.csv
songs_content_features.csv (features normalisÃ©es)
songs_content_features_matrix.npz (matrice sparse)
songs_metadata.csv (titre, artiste pour affichage)
collaborative_data.csv (format Surprise)
scaler.pkl, label_encoders.pkl (pour nouvelles donnÃ©es)


ğŸ““ Notebook 3 : 03_modeling.ipynb
Objectif : DÃ©velopper, entraÃ®ner et Ã©valuer trois modÃ¨les de recommandation.
Cellule 1-2 : Chargement et Configuration

Import des librairies (Surprise, sklearn, pandas)
Chargement de config.yaml
Chargement des donnÃ©es prÃ©traitÃ©es

Cellule 3 : ModÃ¨le Content-Based

Principe : Recommander des chansons similaires basÃ©es sur features audio et mÃ©tadonnÃ©es
Algorithme : SimilaritÃ© cosinus sur matrice de features
Fonction : similar_items(seed_song_id, topk=10)
Avantages : Pas de cold start, couverture maximale (99.5%)
Limite : Manque de dÃ©couverte (recommande toujours du similaire)

Cellule 4 : ModÃ¨le Collaborative Filtering

Principe : Recommander basÃ© sur les goÃ»ts d'utilisateurs similaires
Algorithme : SVD (Matrix Factorization) avec 50 facteurs latents
Librairie : Surprise
EntraÃ®nement : 20 epochs, learning_rate=0.005, regularization=0.02
Avantages : Excellente dÃ©couverte (86.7% sur nouveautÃ©s)
Limite : Cold start pour 42% des utilisateurs (21/50)

Cellule 5 : ModÃ¨le Hybrid

Principe : Fusion pondÃ©rÃ©e avec fallback intelligent
StratÃ©gie :

Si les deux modÃ¨les fonctionnent â†’ Î± Ã— Content + Î² Ã— Collaborative (Î±=Î²=0.5)
Si Collaborative Ã©choue â†’ Fallback sur Content-Based
Si Content Ã©choue â†’ Fallback sur Collaborative


RÃ©sultat : 100% de couverture utilisateurs

Cellule 6 : Ã‰valuation

MÃ©triques : Precision@K, Recall@K, NDCG@K, Coverage, DiversitÃ©
Deux Ã©valuations :

Global (inclut historique train)
Novelties (nouvelles chansons uniquement)


50 utilisateurs Ã©valuÃ©s avec ground truth du test set

Cellule 7 : Analyse de DiversitÃ©

Mesure de la diversitÃ© des genres et artistes
Visualisations comparatives
Identification du modÃ¨le le plus diversifiÃ©

Cellule 8 : RÃ©sumÃ© et Sauvegarde

SynthÃ¨se des performances
Recommandation du meilleur modÃ¨le
Sauvegarde de modeling_summary.json

Sorties :

content_based_model.pkl (matrice + mappings)
collaborative_model.pkl (modÃ¨le SVD entraÃ®nÃ©)
hybrid_config.json (poids Î± et Î²)
evaluation_report.json (toutes les mÃ©triques)
modeling_summary.json (rÃ©sumÃ© complet)


ğŸ“Š 5. RÃ‰SULTATS
5.1 Performances Comparatives
Ã‰valuation Globale
ModÃ¨lePrecision@10Recall@10NDCG@10CoverageTaux SuccÃ¨sContent-Based74.8%4.9%74.1%99.5%100%Collaborative74.7%0.8%21.7%20.5%58%Hybrid74.6%4.9%74.1%91.0%100%
Ã‰valuation Novelties (DÃ©couverte)
ModÃ¨lePrecision@10Recall@10NDCG@10Content-Based1.2%7.3%4.2%Collaborative86.7%100%94.7%Hybrid10.0%78.0%70.8%
5.2 Analyse de DiversitÃ©
ModÃ¨leDiversitÃ© GenreDiversitÃ© ArtisteContent-Based25.0%15.0%Collaborative33.3%66.7%Hybrid20.0%35.0%
5.3 InterprÃ©tation
Content-Based :

âœ… Excellente prÃ©cision globale (74.8%)
âœ… Couverture maximale du catalogue (99.5%)
âœ… Aucun cold start
âŒ TrÃ¨s faible dÃ©couverte (1.2% sur nouveautÃ©s)

Collaborative Filtering :

âœ… Champion de la dÃ©couverte (86.7% sur nouveautÃ©s)
âœ… Meilleure diversitÃ© (33.3%)
âŒ Cold start important (42% d'Ã©checs)
âŒ Couverture limitÃ©e (20.5%)

Hybrid (RecommandÃ©) :

âœ… Performance Ã©quilibrÃ©e (74.6%)
âœ… Aucun cold start (100% succÃ¨s)
âœ… Bonne couverture (91.0%)
âœ… 8Ã— meilleur que content-based pour les nouveautÃ©s (10% vs 1.2%)
âœ… Ã‰quilibre optimal entre pertinence et dÃ©couverte


ğŸ† 6. MODÃˆLE RECOMMANDÃ‰ : HYBRID
6.1 Justification
Le modÃ¨le Hybrid est recommandÃ© pour la production car il offre le meilleur compromis :

FiabilitÃ© : 100% de couverture utilisateurs (vs 58% pour collaborative)
Performance : 74.6% de prÃ©cision (Ã©quivalent aux autres)
DÃ©couverte : 10% sur nouveautÃ©s (8Ã— mieux que content-based)
Couverture catalogue : 91% (Ã©quilibre optimal)
Robustesse : Fallback automatique Ã©limine le cold start

6.2 Fonctionnement
Pour chaque utilisateur :
  1. Essayer Collaborative Filtering
  2. Si succÃ¨s â†’ Fusion 50% Content + 50% Collaborative
  3. Si Ã©chec (cold start) â†’ Fallback sur Content-Based
  
RÃ©sultat : Recommandations pour 100% des utilisateurs

ğŸ” 7. LIMITATIONS ET PERSPECTIVES
7.1 Limitations

Taille du dataset : 50 utilisateurs, 200 chansons (petit Ã©chantillon)
Matrice sparse : 7% de densitÃ© limite les performances collaboratives
Cold start collaborative : 42% d'Ã©checs nÃ©cessite le fallback

7.2 Perspectives d'AmÃ©lioration

Dataset plus large : Tester sur MCRec-30M complet
Deep Learning : Explorer les rÃ©seaux de neurones (NCF, autoencoders)
Features supplÃ©mentaires : Lyrics, audio embeddings (Spotify API)
Filtrage contextuel : IntÃ©grer l'heure, l'humeur, la mÃ©tÃ©o
A/B Testing : Valider avec utilisateurs rÃ©els en production


ğŸ“± 8. APPLICATION WEB INTERACTIVE

8.1 Vue d'Ensemble
Technologies utilisÃ©es :
â€¢ Framework : Streamlit 1.28+
â€¢ Visualisation : Plotly Express 5.18+
â€¢ Manipulation de donnÃ©es : Pandas 2.1+
â€¢ DÃ©ploiement : Local (possibilitÃ© de dÃ©ploiement cloud)

Architecture de l'application :
app/
â”œâ”€â”€ config.py              # Configuration (constantes, styles CSS, emojis)
â”œâ”€â”€ models.py              # Classe RecommendationSystem (chargement modÃ¨les)
â”œâ”€â”€ utils.py               # Fonctions d'affichage (cartes, tableaux, graphiques)
â””â”€â”€ streamlit_app.py       # Application principale (interface utilisateur)

8.2 Fichier config.py
RÃ´le : Centraliser toutes les configurations de l'application

A. Chemins des fichiers :
â€¢ DonnÃ©es : TRAIN_DATA, TEST_DATA, SONGS_CONTENT_FEATURES
â€¢ ModÃ¨les : CONTENT_MODEL, COLLABORATIVE_MODEL, HYBRID_CONFIG
â€¢ Rapports : EVALUATION_REPORT, MODELING_SUMMARY

B. ParamÃ¨tres de l'interface :
â€¢ Titre : "ğŸµ SystÃ¨me de Recommandation Musicale"
â€¢ Layout : "wide" (pleine largeur)
â€¢ Recommandations : MIN=5, MAX=20, DEFAULT=10

C. Styles visuels :
â€¢ CSS personnalisÃ© pour cartes de chansons
â€¢ Palette de couleurs (Spotify-inspired) : #1DB954, #191414
â€¢ Emojis mappÃ©s par genre (ğŸ¤ Pop, ğŸ¸ Rock, ğŸ· Jazz, ğŸ§ EDM)
â€¢ Emojis mappÃ©s par contexte (ğŸ’ª Workout, ğŸ˜Œ Relax, ğŸš— Commute)

8.3 Fichier models.py
RÃ´le : GÃ©rer le chargement et l'utilisation des modÃ¨les de recommandation

Classe RecommendationSystem :

A. MÃ©thode load_all() :
â€¢ Charge songs_content_features.csv (200 chansons + 22 colonnes)
â€¢ Charge train_data.csv (56,101 interactions)
â€¢ Charge les 3 modÃ¨les sauvegardÃ©s (.pkl)
â€¢ CrÃ©e les mappings song_id â†” index
â€¢ Utilise @st.cache_resource pour Ã©viter rechargements
â€¢ âœ… OPTIMISATION : Aucun message de debug affichÃ© (interface propre)

B. MÃ©thodes de recommandation :
1. recommend_content_based(user_id, n=10)
   â†’ Retourne [(song_id, score), ...] basÃ© sur similaritÃ© cosinus

2. recommend_collaborative(user_id, n=10)
   â†’ Retourne [(song_id, score), ...] depuis SVD prÃ©-calculÃ©

3. recommend_hybrid(user_id, n=10, alpha=0.5, beta=0.5)
   â†’ Fusion pondÃ©rÃ©e avec fallback automatique
   â†’ Normalisation min-max des scores
   â†’ Garantit 100% de couverture

C. MÃ©thodes utilitaires :
â€¢ get_song_info(song_id) â†’ Dictionnaire complet (mÃ©tadonnÃ©es + 12 features audio)
â€¢ get_user_history(user_id, n=10) â†’ Historique d'Ã©coute
â€¢ get_model_stats() â†’ Statistiques depuis modeling_summary.json

8.4 Fichier utils.py
RÃ´le : Fonctions d'affichage et visualisation

A. display_song_card(song, show_score=True, show_details=True)
Affiche une carte de chanson avec :
â€¢ En-tÃªte : Titre de la chanson (ğŸµ)
â€¢ MÃ©tadonnÃ©es (3 colonnes) :
  - Colonne 1 : Artiste, Genre (avec emoji)
  - Colonne 2 : Album, AnnÃ©e
  - Colonne 3 : DurÃ©e (MM:SS), PopularitÃ© (/100)
â€¢ Score de recommandation : Barre de progression normalisÃ©e [0-1]
â€¢ Section dÃ©pliable "ğŸ§ DÃ©tails audio" :
  â—¦ Tempo (BPM) - dÃ©normalisÃ© de [-1,1] vers [60-180]
  â—¦ Energy [0-1] - dÃ©normalisÃ© de [-1,1]
  â—¦ Danceability [0-1] - dÃ©normalisÃ©
  â—¦ Valence [0-1] - dÃ©normalisÃ©
  â—¦ Informations supplÃ©mentaires : Mode (Major/Minor), TonalitÃ© (C#, F, etc.), 
    Acoustique, Instrumental, Live, Volume (dB), Langue, Explicite

âœ… Innovation : DÃ©normalisation automatique des features audio
   â€¢ DÃ©tecte si valeurs normalisÃ©es (|x| < 2)
   â€¢ Convertit vers Ã©chelles lisibles pour l'utilisateur
   â€¢ Affiche "N/A" si valeur = 0 (au lieu de 0.000)

B. display_recommendations_table(recommendations)
Affiche les recommandations sous forme de tableau avec :
â€¢ Colonnes : #, Titre, Artiste, Genre, Album, AnnÃ©e, Score, DurÃ©e, PopularitÃ©
â€¢ Normalisation automatique des scores
â€¢ Style DataFrame Streamlit avec largeur adaptative
â€¢ Tri possible par colonne (natif Streamlit)

C. plot_genre_distribution(recommendations)
Graphique en barres groupÃ©es (Plotly) montrant :
â€¢ Axe X : Genres musicaux
â€¢ Axe Y : Nombre de chansons
â€¢ 3 barres par genre : Content-Based, Collaborative, Hybrid
â€¢ Palette : #FF6B6B (rouge), #4ECDC4 (turquoise), #45B7D1 (bleu)

D. plot_diversity_comparison(recommendations)
Graphique en barres comparant la diversitÃ© :
â€¢ DiversitÃ© = Genres uniques / Total chansons
â€¢ Affichage en pourcentage
â€¢ Aide Ã  identifier le modÃ¨le le plus exploratoire

8.5 Fichier streamlit_app.py - Structure
Organisation en 4 onglets principaux :

â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚  ğŸµ SystÃ¨me de Recommandation Musicale                      â”‚
â”‚  SystÃ¨me intelligent basÃ© sur trois approches               â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Sidebar                                                     â”‚
â”‚  â”œâ”€ ğŸ‘¤ SÃ©lectionner un utilisateur (1000-1049)             â”‚
â”‚  â”œâ”€ ğŸ”¢ Nombre de recommandations (5-20, dÃ©faut 10)          â”‚
â”‚  â”œâ”€ ğŸ”€ ModÃ¨le Hybrid                                        â”‚
â”‚  â”‚   â”œâ”€ Content-Based (Î±) : slider 0.0-1.0                 â”‚
â”‚  â”‚   â””â”€ Collaborative (Î²) : slider 0.0-1.0                 â”‚
â”‚  â”œâ”€ ğŸ”„ Recharger les donnÃ©es                                â”‚
â”‚  â””â”€ â„¹ï¸ ParamÃ¨tres actuels                                   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚  Onglets                                                     â”‚
â”‚  [ğŸ  Accueil] [ğŸµ Recommandations] [ğŸ“Š Comparaison] [ğŸ“ˆ Stats] â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

8.6 Onglet 1 : ğŸ  Accueil

A. Profil utilisateur
Affiche les statistiques de l'utilisateur sÃ©lectionnÃ© :
â€¢ MÃ©trique 1 : Total Ã©coutes (nombre d'interactions)
â€¢ MÃ©trique 2 : Chansons aimÃ©es (liked=1)
â€¢ MÃ©trique 3 : Genre prÃ©fÃ©rÃ© (avec emoji, ex: ğŸ¤ Pop)
â€¢ MÃ©trique 4 : Artistes Ã©coutÃ©s (nombre unique)

B. Historique d'Ã©coute
Tableau des 10 derniÃ¨res Ã©coutes avec :
â€¢ Colonnes : Titre, Artiste, Genre, Album, Statut (â¤ï¸ AimÃ© / ğŸ‘ Ã‰coutÃ©)
â€¢ Tri par timestamp dÃ©croissant
â€¢ Style avec DataFrame Streamlit

C. Graphique de distribution
Graphique circulaire (Pie chart Plotly) :
â€¢ RÃ©partition des genres dans l'historique de l'utilisateur
â€¢ Couleurs : palette Set3 (lisible et agrÃ©able)
â€¢ Affichage du pourcentage par genre

8.7 Onglet 2 : ğŸµ Recommandations

A. SÃ©lection du modÃ¨le
Radio buttons horizontal :
â€¢ Content-Based
â€¢ Collaborative
â€¢ Hybrid (avec paramÃ¨tres Î± et Î² de la sidebar)

B. GÃ©nÃ©ration des recommandations
Bouton : "ğŸµ GÃ©nÃ©rer les recommandations" (type primary, rouge)
â€¢ Spinner pendant le calcul
â€¢ Sauvegarde dans st.session_state (persiste entre changements de mode)
â€¢ Message de succÃ¨s : "âœ… 10 recommandations gÃ©nÃ©rÃ©es avec [ModÃ¨le]"

âœ… Innovation : Utilisation de session_state
   â€¢ Les recommandations restent affichÃ©es aprÃ¨s gÃ©nÃ©ration
   â€¢ Le changement de mode d'affichage ne les efface pas
   â€¢ ExpÃ©rience utilisateur fluide sans rechargements

C. Mode d'affichage
Radio buttons horizontal :
â€¢ Cartes : Affichage dÃ©taillÃ© avec features audio
â€¢ Tableau : Vue condensÃ©e avec statistiques et tÃ©lÃ©chargement CSV

Mode Cartes :
â€¢ Une carte par recommandation (fonction display_song_card)
â€¢ NumÃ©rotation : "ğŸµ Recommandation #1", "#2", etc.
â€¢ Section audio dÃ©pliable par dÃ©faut
â€¢ SÃ©parateurs visuels entre cartes

Mode Tableau :
â€¢ DataFrame Streamlit avec colonnes : #, Titre, Artiste, Genre, Album, AnnÃ©e, 
  Score, DurÃ©e, PopularitÃ©
â€¢ Statistiques en 3 colonnes :
  â—¦ Genres diffÃ©rents : Nombre de genres uniques
  â—¦ Artistes diffÃ©rents : Nombre d'artistes uniques
  â—¦ Score moyen : Moyenne des scores normalisÃ©s
â€¢ Bouton tÃ©lÃ©chargement CSV :
  â—¦ Nom : "recommandations_[ModÃ¨le]_[UserID]_[Timestamp].csv"
  â—¦ Encodage UTF-8
  â—¦ IcÃ´ne : ğŸ“¥

8.8 Onglet 3 : ğŸ“Š Comparaison

A. Bouton de comparaison
"ğŸ”„ Comparer les 3 modÃ¨les" (type primary)
â€¢ GÃ©nÃ¨re les recommandations pour Content-Based, Collaborative et Hybrid
â€¢ Utilise get_recommendations_all_models(user_id, n)

B. Affichage en 3 colonnes
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚ ğŸ¸ Content  â”‚ ğŸ¤ Collab   â”‚ ğŸ”€ Hybrid   â”‚
â”œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¤
â”‚ 1. SongA    â”‚ 1. SongX    â”‚ 1. SongM    â”‚
â”‚ ArtistA     â”‚ ArtistX     â”‚ ArtistM     â”‚
â”‚ Pop         â”‚ Jazz        â”‚ Rock        â”‚
â”‚ Score: 0.85 â”‚ Score: 0.92 â”‚ Score: 0.88 â”‚
â”‚ â”€â”€â”€         â”‚ â”€â”€â”€         â”‚ â”€â”€â”€         â”‚
â”‚ 2. SongB    â”‚ 2. SongY    â”‚ 2. SongN    â”‚
â”‚ ...         â”‚ ...         â”‚ ...         â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜

â€¢ Affiche top 5 par modÃ¨le (pour lisibilitÃ©)
â€¢ Normalisation des scores > 1.0
â€¢ Message "Aucune recommandation (cold start)" si Ã©chec

C. Graphique de distribution des genres
Appel Ã  plot_genre_distribution(all_recs)
â€¢ Barres groupÃ©es par genre
â€¢ Comparaison visuelle des 3 modÃ¨les

D. Analyse de diversitÃ©
1. EncadrÃ© explicatif (st.info) :
   "ğŸ“Œ La diversitÃ© mesure la variÃ©tÃ© des genres musicaux
   â€¢ Score Ã©levÃ© (>70%) = DÃ©couverte
   â€¢ Score moyen (40-70%) = Ã‰quilibre
   â€¢ Score faible (<40%) = PrÃ©cision ciblÃ©e
   Formule : (Genres uniques / Total chansons) Ã— 100%"

2. MÃ©triques en 3 colonnes :
   â€¢ Content-Based : X%
   â€¢ Collaborative : Y%
   â€¢ Hybrid : Z%
   Avec tooltip indiquant "X genres diffÃ©rents sur Y chansons"

8.9 Onglet 4 : ğŸ“ˆ Statistiques

A. RÃ©sumÃ© du projet
MÃ©triques globales (3 colonnes) :
â€¢ Utilisateurs : 50
â€¢ Chansons : 200
â€¢ Interactions (train) : 56,101

B. Graphique de comparaison des performances
Fonction plot_model_comparison(stats)
â€¢ Barres groupÃ©es : Precision@10, Coverage, DiversitÃ© (en %)
â€¢ Lecture depuis modeling_summary.json

C. DÃ©tails par modÃ¨le (3 colonnes)
Pour chaque modÃ¨le (Content-Based, Collaborative, Hybrid) :
â€¢ Precision@10 : XX.X%
â€¢ Coverage : XX.X%
â€¢ DiversitÃ© : XX.X%
â€¢ Taux de succÃ¨s : XX.X%
(Collaborative et Hybrid ont aussi Precision Novelties)

D. Recommandation pour production
EncadrÃ© vert (st.success) :
"ğŸ† ModÃ¨le recommandÃ© pour production : Hybrid

Raisons :
 - âœ… Couverture utilisateurs : 100%
 - âœ… PrÃ©cision Ã©quilibrÃ©e : 74.6%
 - âœ… DÃ©couverte : 10% (8Ã— mieux que content-based)
 - âœ… Robustesse : Fallback automatique"

8.10 Optimisations et Bonnes Pratiques ImplÃ©mentÃ©es

A. Performance :
â€¢ @st.cache_resource sur load_system() (TTL 1h)
â€¢ Chargement unique des modÃ¨les au dÃ©marrage
â€¢ Matrice de similaritÃ© en format sparse (Ã©conomie mÃ©moire)
â€¢ Session state pour Ã©viter recalculs inutiles

B. ExpÃ©rience utilisateur :
â€¢ Interface propre : Aucun message de debug affichÃ©
â€¢ Feedback visuel : Spinners pendant les calculs
â€¢ Messages clairs : SuccÃ¨s (vert), Erreurs (rouge), Infos (bleu)
â€¢ Navigation intuitive : 4 onglets bien sÃ©parÃ©s

C. Robustesse :
â€¢ Gestion des valeurs manquantes (fillna, get avec dÃ©faut)
â€¢ Normalisation automatique des scores
â€¢ DÃ©normalisation intelligente des features audio
â€¢ Fallback sur valeurs par dÃ©faut si fichiers manquants

D. MaintenabilitÃ© :
â€¢ Code modulaire : config.py, models.py, utils.py sÃ©parÃ©s
â€¢ Fonctions rÃ©utilisables (display_song_card, plot_genre_distribution)
â€¢ Constantes centralisÃ©es (GENRE_EMOJIS, COLOR_PRIMARY)
â€¢ Documentation docstrings pour chaque fonction

8.11 Captures d'Ã‰cran RecommandÃ©es
(Ã€ ajouter dans le rapport final)

1. Onglet Accueil : Profil utilisateur avec historique
2. Onglet Recommandations (Mode Cartes) : Cartes dÃ©taillÃ©es
3. Onglet Recommandations (Mode Tableau) : Vue tableau + CSV
4. Onglet Comparaison : 3 colonnes avec graphiques
5. Onglet Statistiques : Graphiques de performances

8.12 DÃ©ploiement

A. ExÃ©cution locale :
```bash
cd music-recommendation-system
streamlit run app/streamlit_app.py
```
â†’ Ouvre automatiquement http://localhost:8501

B. Options de dÃ©ploiement cloud (futures) :
â€¢ Streamlit Community Cloud (gratuit, recommandÃ©)
â€¢ Heroku (avec buildpack Python)
â€¢ AWS EC2 / Google Cloud Run
â€¢ Azure Web Apps

C. PrÃ©requis de dÃ©ploiement :
â€¢ requirements.txt avec versions exactes
â€¢ Fichiers .pkl < 100 MB (OK pour ce projet)
â€¢ Python 3.9+ recommandÃ©

8.13 Guide d'Utilisation pour l'Utilisateur Final

1. Lancement de l'application
   â†’ Streamlit dÃ©marre automatiquement dans le navigateur

2. SÃ©lection d'un utilisateur (Sidebar)
   â†’ Choisir parmi 50 utilisateurs (ID 1000-1049)

3. Exploration du profil (Onglet Accueil)
   â†’ Consulter l'historique et les prÃ©fÃ©rences

4. GÃ©nÃ©ration de recommandations (Onglet Recommandations)
   a. SÃ©lectionner un modÃ¨le (Content, Collaborative ou Hybrid)
   b. Ajuster le nombre de recommandations (5-20)
   c. Si Hybrid : Ajuster Î± et Î² dans la sidebar
   d. Cliquer sur "GÃ©nÃ©rer les recommandations"
   e. Choisir le mode d'affichage (Cartes ou Tableau)
   f. Explorer les dÃ©tails audio de chaque chanson
   g. (Mode Tableau) TÃ©lÃ©charger le CSV si besoin

5. Comparaison des modÃ¨les (Onglet Comparaison)
   â†’ Comparer les rÃ©sultats des 3 approches cÃ´te Ã  cÃ´te
   â†’ Analyser la diversitÃ© de chaque modÃ¨le

6. Consultation des statistiques (Onglet Statistiques)
   â†’ Comprendre les performances globales
   â†’ Identifier le modÃ¨le optimal

8.14 Retour d'ExpÃ©rience sur le DÃ©veloppement

A. DÃ©fis rencontrÃ©s :
â€¢ DÃ©normalisation des features audio : NÃ©cessitÃ© de dÃ©tecter automatiquement 
  si les valeurs sont normalisÃ©es ([-1,1]) ou brutes
â€¢ Persistance des recommandations : ProblÃ¨me initial oÃ¹ changer le mode 
  d'affichage effaÃ§ait les rÃ©sultats â†’ RÃ©solu avec st.session_state
â€¢ Gestion du cold start : 42% des utilisateurs sans recommandations 
  collaboratives â†’ RÃ©solu avec le modÃ¨le hybrid et fallback

B. Solutions innovantes :
â€¢ Fonction de dÃ©normalisation intelligente dans utils.py
â€¢ SystÃ¨me de session_state pour fluiditÃ© de navigation
â€¢ Affichage conditionnel "N/A" au lieu de 0.000 pour meilleure UX
â€¢ Bouton de tÃ©lÃ©chargement CSV avec horodatage dans le nom

C. AmÃ©liorations futures possibles :
â€¢ SystÃ¨me de feedback utilisateur (ğŸ‘ğŸ‘ sur chaque recommandation)
â€¢ Playlists personnalisÃ©es (sauvegarde des favoris)
â€¢ Recherche de chansons par titre/artiste
â€¢ Filtres avancÃ©s (genre, annÃ©e, tempo)
â€¢ Mode sombre / clair
â€¢ Graphiques interactifs avancÃ©s (radar chart des features audio)
â€¢ IntÃ©gration API Spotify pour prÃ©visualisation audio

8.15 Conclusion de la Partie Application

L'application Streamlit dÃ©veloppÃ©e constitue une interface professionnelle et 
intuitive pour le systÃ¨me de recommandation musicale. Elle permet :

âœ… Une exploration complÃ¨te des recommandations des 3 modÃ¨les
âœ… Une visualisation dÃ©taillÃ©e des features audio de chaque chanson
âœ… Une comparaison objective des performances
âœ… Une expÃ©rience utilisateur fluide et sans friction
âœ… Un outil de validation et de dÃ©monstration du projet

L'interface rÃ©pond aux objectifs fixÃ©s et offre une base solide pour un 
dÃ©ploiement en production aprÃ¨s enrichissement avec un dataset plus large.


ğŸ” 9. LIMITATIONS ET PERSPECTIVES
[Reprendre la partie 7 existante]

âœ… 10. CONCLUSION GÃ‰NÃ‰RALE
[Reprendre et enrichir la conclusion existante]

Ce projet a permis de dÃ©velopper avec succÃ¨s un systÃ¨me de recommandation 
musicale complet, de l'exploration des donnÃ©es jusqu'au dÃ©ploiement d'une 
application web interactive. Les rÃ©sultats dÃ©montrent que :

âœ… Le pipeline de prÃ©traitement permet une Ã©valuation robuste et reproductible
âœ… Le modÃ¨le hybrid rÃ©sout efficacement le problÃ¨me du cold start
âœ… Les performances sont comparables aux standards industriels (74.6% prÃ©cision)
âœ… L'application Streamlit offre une interface professionnelle et intuitive
âœ… Le systÃ¨me est prÃªt pour un dÃ©ploiement en production (aprÃ¨s scaling)

Contributions principales :
1. DÃ©veloppement d'un modÃ¨le hybrid avec fallback intelligent garantissant 
   100% de couverture utilisateurs
2. Pipeline de prÃ©traitement avec split stratifiÃ© par utilisateur
3. Application web complÃ¨te avec 4 modes de visualisation
4. SystÃ¨me de dÃ©normalisation automatique des features audio pour l'affichage

Impact potentiel :
â€¢ Base solide pour un systÃ¨me de recommandation rÃ©el
â€¢ Architecture rÃ©utilisable pour d'autres projets de recommandation
â€¢ Documentation complÃ¨te facilitant la maintenance et l'Ã©volution


ğŸ“š 11. RÃ‰FÃ‰RENCES

Dataset :
â€¢ MCRec-30M (Music Contextual Recommendation Dataset)
â€¢ Source : Domaine public, adaptÃ© pour ce projet
â€¢ Taille : 70,129 interactions, 50 utilisateurs, 200 chansons

Librairies et Frameworks :
â€¢ Surprise 1.1.3 : Algorithmes de recommandation (SVD)
â€¢ Scikit-learn 1.3+ : Normalisation, similaritÃ© cosinus
â€¢ Pandas 2.1+ : Manipulation de donnÃ©es
â€¢ Streamlit 1.28+ : Interface web
â€¢ Plotly 5.18+ : Visualisations interactives

MÃ©triques et Standards :
â€¢ Precision@K, Recall@K, NDCG : MÃ©triques standards en recommandation
â€¢ Coverage : Pourcentage du catalogue recommandÃ©
â€¢ Diversity : VariÃ©tÃ© des genres et artistes recommandÃ©s

RÃ©fÃ©rences acadÃ©miques :
â€¢ Koren, Y. et al. (2009). "Matrix Factorization Techniques for Recommender Systems"
â€¢ Herlocker, J. et al. (2004). "Evaluating Collaborative Filtering Recommender Systems"
â€¢ Ricci, F. et al. (2015). "Recommender Systems Handbook"

Documentation :
â€¢ Surprise Documentation : https://surprise.readthedocs.io/
â€¢ Streamlit Documentation : https://docs.streamlit.io/
â€¢ Scikit-learn User Guide : https://scikit-learn.org/stable/user_guide.html


ğŸ“Š 12. ANNEXES

A. Structure ComplÃ¨te des Fichiers
[Arborescence dÃ©taillÃ©e du projet]

B. Configuration YAML ComplÃ¨te
[Contenu de config.yaml]

C. Fonctions Principales
[Signatures des fonctions clÃ©s avec docstrings]

D. Commandes d'ExÃ©cution
[Liste des commandes pour reproduire le projet]

E. DÃ©pendances (requirements.txt)
```
streamlit==1.28.0
pandas==2.1.0
numpy==1.24.0
scikit-learn==1.3.0
scikit-surprise==1.1.3
plotly==5.18.0
scipy==1.11.0
pyyaml==6.0.1
```


ğŸ“ FIN DU RAPPORT

